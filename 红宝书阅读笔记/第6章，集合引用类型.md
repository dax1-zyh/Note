## 第6章，集合引用类型



### Object

在对象字面量表示法中，属性名可以是字符串或数值

```js
let person = {
	"name":"Frank",
	"age":29,
	5:true
}
```

这个例子会得到一个带有属性`name` 、`age` 和 `5`的对象。 （数值属性会自动转换为字符串）

```js
let person = {} 	// 与new Object()相同
```

```JS
console.log(person.name)		//"Frank"
console.log(person["name"])		//"Frank"
```

这两种读取属性的方式没有区别。如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，可以使用中括号语法。



### Array



**创建数组**

跟其他语言不同的是，数组中的每个槽位可以存储**任意类型**的数据，同时也是**动态大小**的，会随着数据添加而自动增长。

```
let colors = Array(3)		//创建一个包含3个元素的数组
let names = Array("Greg")	//创建一个只包含一元素“Greg”的数组
```



ES6新增用于创建数组的静态方法 `from()`和 `of()` 。 `from()`用于将**类数组结构**转换为数组实例，而 `of()`用于将**一组参数**转换为数组实例。

使用场景

- `from()`可将函数的多个参数arguments转换为真正的数组
- `of()`按照传入的数据组成一个数组



**数组空位**

```js
const options = [,,,,,]			//创建包含5个元素的数组
```

ES6将这些空位当成存在的元素，只不过值为`undefined`



**数组索引**

数组`length`属性的独特之处在于，它不是只读的。通过修改 `length`属性，可以从数组末尾删除或添加元素



**检测数组**

`isArray()`方法



**复制和填充方法**			p143

批量复制方法 `fill()` ,填充数组方法 `copyWithin()`

`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素,不包括终止索引。忽略超出数组边界、零长度及方向相反的索引范围

```js
const zeroes = [0,0,0,0,0]

zeroes.fill(5）				//用5填充整个数组
zeroes.fill(6，3)			//用6填充索引大于等于3的元素
zeroes.fill(7，1，3)	       //用6填充索引大于等于1且小于3的元素
zeroes.fill(8,-4,-1)		//用8提案冲索引大于等于1且小于4的元素
```

`copyWithin()` 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。

[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)



**转换方法**

`valueOf()`返回的还是数组本身

`toString()`返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串，也就是说，对数组每个值都会调用 `toString()`方法，得到最终的字符串。



**栈方法**

栈是一种**后进先出(LIFO)**的结构，数据项的插入（称为**推入，push**）和删除（称为**弹出，pop**）只在栈的一个地方发生，即栈顶。

`push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。

`pop()`方法则用于删除数组的最后一项，同时减少数组的length值，**返回被删除的项**。



**队列方法**

队列以**先进先出(FIFO)**形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。

`shift()`删除数组的第一项，并返回它
`unshift()`在数组开头添加任意多个值，然后返回新的数组长度



**排序方法**

`reverse()`方法将数组元素反向排列

`sort()`方法，默认情况下，会按照升序重新排列数组元素。为此，`sort()`会在每一项上调用 `string()`转型函数，然后比较字符串来决定顺序。

```js
let values = [0,1,5,10,15]
values.sort()
alert(values)			//0，1，10，15，5
```

一开始数组中数值的顺序是正确的，但调用 `sort()`会按照这些数值的字符串形式（字符串编码顺序）重新排序。

很明显这在多数情况下都不是最合适的，为此 `sort()`方法可以接收一个**比较函数**，用于判断哪个值应该排在前面。

```js
function compare (value1,value2){
	if (value1 < value2) {
		return -1
	} else if (value1 > value2){
		return 1
	} else {
		return 0
	}
}
```

这个比较函数可以适用于大多数数据类型，可以把他当作参数传给`sort()`方法

```js
let values = [0,1,5,10,15]
values.sort(compare)
alert(values)		//0,1,5,10,15
```

比较函数也可以产生降序效果，只需要把返回值交换一下即可。



此外这个比较函数还可简写为一个箭头函数

```js
values.sort((a,b) => a<b ? 1 : a>b ? -1 : 0)
```



如果数组的元素是数值，这个比较函数还可以写的更简单，因为这时可以直接用第二个值减去第一个值

```js
function compare (value1,value2){
	return value2 - value1
}
```

比较函数就是返回小于0、0和大于0的数值，因此剑法操作完全可以满足要求。



**操作方法**

`concat()`在现有数组全部元素基础上创建一个新的数组，用于连接数组。

`slice()`用于创建一个包含原有数组中一个或多个元素的新数组。（裁剪出原数组中的一部分）

`splice()`主要目的是在数组中间插入、替换、删除元素。返回一个数组，包含从原数组中被删除的元素。

之前总结过一篇 `slice` 和 `splice` 的帖子 [CSDN链接](https://blog.csdn.net/Dax1_/article/details/120050319)



**迭代方法**

每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用于对象（影响函数中this的值）。

传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。

- `every()`对数组每一项都运行传入的函数，如果对每一项函数都返回true,则这个方法返回true
- `filter()`对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回
- `forEach()`对数组每一项都运行传入的函数，**没有返回值**
- `map()`对数组每一项都运行传入的函数，**返回由每次函数调用的结果构成的数组**
- `some()`对数组每一项都运行传入的函数，如果有意向函数返回true，则这个方法返回true。

这些方法都不改变调用他们的数组。



**归并方法**

`reduce()`和`reduceRight()`这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。

`reduce()`方法从数组第一项开始遍历到最后一项，`reduceRight()`从最后一项开始遍历至第一项。



**Map**

ES6新增特性，Map是一种新的集合类型，为这门语言带来了真正的键/值存储机制。

使用new关键字和Map构造函数可以创建一个空映射

```js
const m = new Map()，
```

在创建的同时初始化实例

```
const m1 = new Map({
	["key1","val1"],
	["key2","val2"],
	["key3","val3"],
})；
alert(m1.size)		//3
```

初始化之后，可以使用`set()`方法再添加键值对。另外可以使用`get()`和`has()`进行查询，可以通过`size`属性获取映射中的键值对的数量，还可以使用`delete()`和 `clear()`删除值。



与Object不同的是，Object只能使用数值、字符串或符号作为键，Map可以使用任何JS数据类型作为键。



**选择Object还是Map**	P168

- 内存占用

  给定固定大小的内存，Map大约可以比Object多存储50%的键值对

- 插入性能

  如果代码涉及大量插入操作，那么显然Map性能更佳

- 查找速度

  如果代码涉及大量查找操作，那么某些情况下可能选择Object更好一些

- 删除性能

  对大多数浏览器引擎来说，Map的 `delete()`操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择Map



**Set**

Set在很多方面更像是加强的Map，因为他们大多数API和行为都是共有的。

```
const m = new Set()		//创建一个空集合

const s1 = new Set(["val1","val2","val3"])
```

初始化之后，可以使用 `add()`增加值，使用 `has()`查询，通过size取得元素数量，以及使用 `delete()`和 `clear()`删除元素
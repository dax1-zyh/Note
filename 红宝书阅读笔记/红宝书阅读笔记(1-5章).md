> 今天是2021年8月15日 ，在自学的同时开始阅读前端相关的书籍，愿不断在学习中进步。
> 这一本是《JavaScript高级程序设计》（第四版），也俗称红宝书，第四版中加入了ES6。 
> 下一本目标是《JavaScript Dom编程艺术》（第二版），已经在边上摆着了。
> 再下一本？可能是《你不知道的JavaScript》（上卷），也有可能是《图解HTTP》，对面试有点帮助 。
> 开冲！

--------------
## 第1章，什么是JavaScript
**1995年，JavaScript问世**

**JS之父：Brendan Eich**

**完整的JavaScript实现包含以下几个部分**

 - 核心（ECMAScript）
 - 文档对象模型（DOM）
 - 浏览器对象模型（BOM）

 **DOM是一个API，将整个页面抽象为一组分层节点，页面的每个组成部分都是一种节点，包含不同数据。通过DOM可以轻松地删除、添加、替换、修改节点。**

**BOM，可以操控浏览器显示页面之外的部分。**

**※小结**

 - EMCAScript：由ECMA-262定义并提供核心功能
 - 文档对象模型（DOM）：提供与网页内容交互的方法和接口
 - 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口

---------

## 第2章，HTML中的JavaScript
**script元素有下列8个属性**

 - **async**：可选，异步
 - **charset**：可选，使用src属性指定的代码字符集
 - **crossorigin**：可选，配置相关请求的CORS（跨域资源共享）设置
 - **defer**：可选，表示文档解析和显示完成后再执行脚本是可行的，只对外部脚本文件有效
 - **integrity**：可选，可用于确保CDN不会提供而已内容
 - **language**：废弃
 - **src**：可选，表示包含要执行的代码的外部文件
 - **type**：可选，代替language，表示脚本语言的内容类型

**页面在浏览器解析到\<body>的起始标签时开始渲染**
**浏览器在解析到结束的\</html>标签才会执行**

**推迟执行脚本**

 - defer属性
 - 告诉浏览器应该立即开始下载，但执行应该推迟
 - 按照出现的顺序执行
 - 只对外部脚本文件有效

**异步执行脚本**

 - async属性
 - 告诉浏览器立即开始下载，但执行应该推迟
 - 不保证按照出现的次序执行
 - 只对外部脚本文件有效

**行内代码与外部文件**
**推荐使用外部文件，理由如下：**

 - **可维护性**：JS代码如果分散到很多HTML页面，会导致维护困难。
 - **缓存**：浏览器会根据特定的设置缓存所有外部链接的JS文件，意味着如果两个页面用到同一个文件，则该文件只需下载一次，最终意味着页面加载更快。
 - **适应未来**：把JS代码放到外部文件中，就不必考虑用XHTML或其他注释黑科技。

**doctype文档模式**

 - 混杂模式
 - 标准模式
 - 准标准模式

 **※小结**

 - 要包含外部JS文件，必须将src属性设置为要包含文件的URL，文件可以跟网页在同一台服务器上，也可以位于完全不同的域
 - 通常把\<script>元素放到页面末尾，介于主内容之后及\</body>标签之前
 - defer和async的异同

-------------------
## 第3章，语言基础
**var、let和const**

之前总结了一篇文章，写的比较详细：[深入理解var、let和const](https://blog.csdn.net/Dax1_/article/details/119967228)

**声明风格及最佳实践**

 - 不使用var
 - const优先，let次之

const声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。

**数据类型（六种简单数据类型和一种复杂数据类型）**

 - number
 - boolean
 - string
 - symbol（ES6新增）
 - null
 - undefined
 - object

**undefined == true** //true

**永远不用显式地将变量值设置为undefined。但null不是，任何时候，只要变量要保存对象，而当时又没有对象可保存，就要用null来填充**

<br>

**数值转换**

 - number()
 - parseInt()
 - parseFloat()

**转换为字符串**

 - toString

 toString()方法可见于数值、布尔值、对象和字符串值，null和undefined值没有toString()方法。

**用加号操作符给一个值加上一个空字符串""也可以将其转换为字符串**

**字符串插值：\`${}\`**

**指数操作符**

 - Math.pow()有自己的操作符**


----------------
## 第4章，变量、作用域与内存
**ECMAScript变量可以包含两种不同类型的数据**

 - **原始值**：就是最简单的数据
 - **引用值**：多个值构成的对象

在把一个值赋给变量时，JS引擎必须确定这个值是原始值还是引用值。保存原始值的变量是**按值**（value）访问的，因为我们操作的就是 存储在变量中的实际值。

引用值是保存在内存中的对象。JS不允许直接操作对象所在内存地址。在操作对象时，实际上操作的是对该对象的**引用**（reference）而非实际的对象本身。为此，保存引用值的变量是**按引用**（by reference）访问的。

**动态属性**

 - 对于引用值而言，可以随时添加、修改和删除其属性和方法。
 - 而原始值不能有属性，尽管尝试给原始值添加属性不会报错。

**复制值**

 - 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。
 - 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个**指针**，它指向存储在堆内存中的对象。如下：

```javascript
let obj1 =new Object();
let obj2 =new Object();
obj1.name = "frank"
console.log(obj2.name) 	//"frank"
```

**传递参数**：所有函数的参数都是**按值**传递的。

```javascript
function setName(obj){
	obj.name="frank"
	obj = new Oject()
	obj.name="Greg"
}

let person = new Object()
setName(person)
console.log(person.name)	//"frank"
```

如果person是按引用传递的，那么person应该自动将指针改为指向name为“Greg”的对象。而是当我们再次访问person.name时，他的值是“frank”，这表明函数中参数的值改变之后，原始的引用仍然没变。当obj在函数内部被重写时，它变成了一个指向本地对象的指针，而那个本地对象在函数执行结束时就被销毁了。

**确定类型**

typeof操作符适合用来判断一个变量是否为原始类型（如果值是**对象或null**，typeof返回object）

typeof虽然对原始值很有用，但是对引用值的用处不大。ECMAScript提供了**instanceof操作符**

语法：`result = variable instanceof constructor`

如果变量是给定引用类型的实例，则instanceof操作符返回true

```javascript
console.log(person instanceof Object)	//变量person是Object吗？
console.log(colors instanceof Array)	//变量colors是Array吗？
```
按照定义，所有引用值都是Object的实例，因此检测任何引用值和Object构造函数都会返回true，如果监测的是原始值，则会返回false，因为原始值不是对象。

**执行上下文与作用域**

全局上下文就是常说的window对象，因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器。）

上下文中的代码在执行的时候，会创建变量对象的一个**作用域链（scope chain）**。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。

**总结**：内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。

**作用域链增强**

 - try/catch语句的catch块
 - with语句
 - 这两种情况下，都会在作用域链前端添加一个变量对象。
 - 对with语句来说，会向作用域链前端添加指定的对象
 - 对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

**垃圾回收**

通过自动内存管理实现内存分配和闲置资源回收

基本思路：确定哪个变量不会再使用，然后释放它所占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动运行。

 - JS最常用的垃圾回收策略是**标记清理**
 - 另一种没那么常用的垃圾回收策略是**引用计数**

**内存管理**

 - 通过const和let声明提升性能
 - 隐藏类和删除操作
 - 内存泄漏（意外声明全局变量、定时器、闭包等）
 - 静态分配与对象池

> 这部分关于垃圾回收的知识点感觉有点突兀，后面关于”垃圾回收、内存“这块内容，专门总结一篇文章好了

**※小结**

**JS变量可以保存为两种类型的值：原始值和引用值。**

 - 原始值大小固定，因此保存在栈内存上
 - 从一个变量到另一个变量复制原始值会创建该值的第二个副本
 - 引用值是对象，存储在堆内存上
 - 包含引用值的变量实际上只包含指向响应对象的一个指针，而不是对象本身
 - 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象
 - typeof可以确定值的原始类型，而instanceof用于确保值的引用类型

**任何变量都存在于某个上下文中**

 - 执行上下文分全局上下文、函数上下文和块级上下文
 - 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数
 - 函数或块的局部上下文不仅可以访问自己作用域内的变量，也可以访问任何包含上下文乃至全局上下文中的变量
 - 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据
 - 变量的执行上下文用于确定什么时候释放内存

**JS是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收**

 - 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除
 - 主流的垃圾回收算法是标记清理，即先给当前不适用的值加上标记，再回来回收它们的内存。
 - 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JS引擎不再使用这样的算法，但某些旧版本的IE仍会然会受这种算法的影响
 - 引用计数在代码中存在循环引用时会出现问题
 - 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。



## 第5章，基本引用类型



引用值（或者对象）是某个特定**引用类型**的实例。

对象被认为是某个特定引用类型的**实例**。新对象通过`new`操作符后跟一个**构造函数**来创建。构造函数就是用来创建新对象的函数，例如下行

```js
let now = new Date()		
```

这行代码创建了引用类型Date的一个新实例，并将它保存在变量`now`中。`Date（）`在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。



### Date

要创建日期对象，就使用`new`操作符来调用`Date`构造函数

```js
let now = new Date()
```

两个辅助方法 `Date.parse()`和 `Date.UTC()`



 **`Date.parse()`**方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。

比如要创建一个表示“2019年5月23日”的日期对象，可以使用如下代码

```js
let someDate = new Date("May 23, 2019")
```

如果传给`Date.parse()`的字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()。

换句话说，下面这行代码跟前面那行代码是等价的。

```js
let someDate = new Date("May 23, 2019")
```

这两行代码得到的日期对象相同。



**`Date.UTC()`**方法也返回日期的毫秒表示，但使用的是跟`Date.parse()`不同的信息来生成这个值。

传给`Date.UTC()`的参数是年、零起点月数、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。

```js
// GMT时间2000年1月1日0点
let y2k = new Date(Date.UTC(2000,0))

// GMT时间2005年5月5日下午5点55分55秒
let allFives = new Date(Date.UTC(2005,4,5,17,55,55))
```



ECMAScript还提供了`Date.now()`方法，返回表示方法执行时日期和时间的毫秒数。

Date类型的`valueOf()`方法不反悔字符串，这个方法被重写后返回的是日期的毫秒表示。



### 原始值包装类型

ECMAScript提供了3种特殊的引用类型：`Boolean`、`Number`和`String`

每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出原始值的各种方法。

```js
let s1 = "some text"
let s2 = s1.substring(2)
```

这里，原始值本身不是对象，因此逻辑上不应该有方法，而实际上这个例子又确实按照预期运行了。因为后台进行了后台处理，相当于做了以下3步处理

1. 创建一个String类型的实例
2. 调用实例上的特定方法
3. 销毁实例

可以把这3步想象成执行了以下代码

```js
let s1 = new String("some text")
let s2 = s1.substring(2)
s1 = null
```

这种行为可以让原始值拥有对象的行为，对Boolean和Number包装类型也有效。



**引用类型与原始值包装类型的主要区别在于对象的生命周期。**再通过new实例化引用类型后，得到的实例会在离开作用域时被小汇，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。

```js
let s1 = "some text"
s1.color = "red"
console.log(s1.color)	//undefined
```

这里的原因是第二行代码运行时会临时创建一个String对象，而当第三行代码执行时，这个对象已经销毁了。实际上，第三行代码在这里创建了自己的String对象，但这个对象没有color属性。



**Boolean**

Boolean的实例会重写`valueOf()`方法，返回一个原始值true或false。`toString()`方法被调用时也会被覆盖，返回字符串“true”或“false”



**Number**

Number类型也重写了`valueOf()`、`toLocalString()`和`toString()`方法。`valueOf()`方法返回Number对象表示的原始数值，另外两个方法返回数值字符串。`toString()`方法可选地接收一个表示基数地参数，并返回相应基数形式地数值**字符串**

```js
let num = 10
console,log(num.toString())		//"10"
console,log(num.toString(2))	//"1010"
console,log(num.toString(8))	//"12"
console,log(num.toString(10))	//"10"
console,log(num.toString(16))	//"a"
```



`toFixed()`方法返回包含指定小数点位数的数值字符串。如果数值本身的小数位数超过了参数指定的位数，则四舍五入到最接近的小数位

```js
let num = 10.005
console.log(num.toFixed(2))		//"10.01"
```



`toExponential()`返回以科学计数法表示的数值字符串。接收一个参数，表示结果中小数的位数。



`toPrecision()`方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学计数法。这个方法接收一个参数，表示结果中数字的总位数。

```js
let num = 99
console.log(num.toPrecision(1))		//"1e+2"
console.log(num.toPrecision(2))		//"99"
console.log(num.toPrecision(1))		//"1e+2"
```



`isInteger()`用于辨别一个数值是否保存为整数。有时，小数位的0可能会让人误以为数值是一个浮点值。

```js
console.log(Number.isInteger(1))		//"true"
console.log(Number.isInteger(1.00))		//"true"
console.log(Number.isInteger(1.01))		//"false"
```



**String**

每个String对象都有一个length属性，表示字符串中字符的数量



`concat()`用于将一个或多个字符串拼接成一个新字符串。可以接受任意多个参数，因此可以一次性拼接多个字符串。



**3个从字符串提取子字符串的方法**  P121

`slice()、substr()、substring()`

- 这三个方法都返回调用他们的字符串的子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。
- 对 `slice()`和 `substring()`而言，第二个参数是提取结束的位置（即**该位置之前**的字符会被提取出来）。
- 对 `substr()`而言，第二个参数表示**返回的子字符串数量**。

任何情况下，省略第二个参数都意味着提取到字符串末尾。

```js
let str = "hello world"
console.log(str.slice(3))			//"lo world"
console.log(str.substring(3))		//"lo world"
console.log(str.substr(3))			//"lo world"
console.log(str.slice(3,7))			//"lo w"
console.log(str.substring(3,7))		//"lo w"
console.log(str.substr(3,7))		//"lo worl"
```



当某个参数是负数时，这3个方法的行为又有不同。

- `slice()`方法将所有负值参数都当成字符串长度加上负参数值
- `substr()`方法将第一个负参数值当成字符串长度加上该值，将第二个负参数转换为0。
- `substring()`方法会将所有负参数值都转换为0。

```js
let str = "hello world"
console.log(str.slice(-3))			//"rld"
console.log(str.substring(-3))		//"hello world"
console.log(str.substr(-3))			//"rld"
console.log(str.slice(3,-4))		//"lo w"
console.log(str.substring(3,-4))	//"hell"	
console.log(str.substr(3,-4))		//" "(empty string)
```

第六行，`substring(3,0)`等价于`substring(0,3)`,因为这个方法会将较小的参数作为起点，将较大的参数作为终点。



**字符串位置方法**

`indexOf()`和`lastIndexOf()`两个方法从字符串中搜索传入的字符串，并返回下标（如果没找到，则返回-1），区别在于前者从字符串开头向后开始查找，后者从字符串末尾向前开始查找。

这两个方法都可以接收第二个参数，表示开始搜索的位置。

```
let str = "hello world"
console.log(str.indexOf("o",6))			//7
console.log(str.lastIndexOf("o",6))		//4
```



**字符串包含方法**

3个用于判断字符串种是否包含另一个字符串的方法：`startWith()`、`endWith()`和`incluedes()`，都返回一个表示是否包含的布尔值。区别在于

- `startWith()`检查开始于索引0的匹配项
- `endWith()`检查开始于索引`(string.length - substring.length)`的匹配项
- `includes()`检查整个字符串



`startWith()`、`includes()`接收可选的第二个参数，表示开始搜索的位置。

`endsWith()`接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。



**trim()方法**

这个方法创建字符串的一个副本，删除前、后所有空格符，再返回结果。



**repeat()方法**

这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。



**padStart()和padEnd()方法**

这两个方法会复制字符串，如果小于指定长度，则再相应一边填充字符，直至满足长度条件。第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。

可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配长度。

```
let str = "foo"

console.log(str.padStart(6))		//"   foo"
console.log(str.padStart(9,"."))	//"......foo"

console.log(str.padEnd(8,"bar"))	//"foobarba"
console.log(str.padEnd(9,"."))		//"foo......"
```



**字符串大小写转换**

`toLowerCase()`、`toLocaleLowerCase()`、`toUpperCase()`和`toLocaleUpperCase()`



### 单例内置对象



**Global**

事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成Global对象的属性。



**window对象**

浏览器将window对象时限为Global对象的代理，因此所有全局作用域中声明的变量和函数都变成了window的属性。



**Math**

`min()` `max()`用于确定一组数值中的最大值和最小值



- `Math.ceil()` 方法始终向上舍入为最接近的整数
- `Math.floor()` 方法始终向下舍入为最接近的整数
- `Math.round()` 方法执行四舍五入
- `Math.fround()` 方法返回数值最接近的单精度（32位）浮点值表示



`Math.random()`方法返回一个0~1范围内的随机数，包括0但不包含1


